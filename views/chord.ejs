<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 12px sans-serif;
  background-color: black;
}

.chord path {
  fill-opacity: .79;
}

</style>
<body>
<script src="/js/d3.js"></script>
<script type="text/javascript">
/***************************** find_unique function *****************************/
function find_unique(string){
  var split_str = string.split(" ");
  var unique_str = [];
  var check = 0;
  for (var i = 0; i < split_str.length; i++) {
    for (var j = 0; j < unique_str.length; j++) {
      if (unique_str[j] == split_str[i]){
        check = 1;
        j=unique_str.length;
      }
      else{
        check = 0;
      }
    }
    if (check === 0) {
      unique_str.push(split_str[i]);
    }
  }
  return unique_str;
}
var orig_str = "Annie Ashe Annie Caitlyn Darius Diana Elise Evelyn Janna Katarina Leona Lulu Olaf Oriana Viktor Vladimir Ahri Mundo Draven Fiora Garen Jayce Kayle Malzahar Yi Nami Nunu Poppy Shen Shyvana Tristana Vayne Wukong Xin Zhao Yorick Akali Alistar Amumu Anivia Cassiopeia Corki Ezreal Gragas Heimerdinger Irelia Jarvan Jax Karma Karthus Kassadin Kennen Lux Morgana Nasus Nidalee Riven Ryze Sejuani Sivir Sona Soraka Swain Syndra Taric Varus Warwick Zed Zilean Blitzcrank Brand Cho' gath Fiddlesticks Fizz Galio Hecarim Kha' zix Kog' maw LeBlanc Malphite Maokai Mordekaiser Rammus Renekton Rengar Shaco Sion Skarner Teemo Trundle Tryndamere Udyr Urgot Veigar Xerath Ziggs Zyra Lee Sin Miss Fortune Nautilus Nocturne Pantheon Rumble Singed Talon Thresh Twisted Fate Twitch Vi Volibear";

//var orig_str = "Annie Ashe Annie Caitlyn Darius Annie Annie Annie Diana Elise Evelyn Janna Katarina Leona Lulu Olaf Oriana Viktor Vladimir";

//find_unique(orig_str);
var word_array = find_unique(orig_str);
//["Annie", "Ashe", "Caitlyn",  "Darius", "Diana", "Elise", "Evelyn", "Janna", "Katarina", "Leona", "Lulu", "Olaf", "Oriana", "Viktor", "Vladimir"]




/***************************** create_matrix function *****************************/

function create_matrix(orig_string, array){
    // console.log(array);
    // console.log(orig_string);
  var matrix = [];
  // var inner_array = [];
  // var check = 0;
  var whole_string = orig_string.split(/\s+/g);
  var x = 0;
  var y = 0;
    for (i=0;i<array.length;i++) {
        matrix[i] = new Array();
        for (j=0;j<array.length;j++) {
            matrix[i][j]=0;
        }
    }
    // x = array.indexOf(whole_string[whole_string.length-1]);
    // // console.log("*****", whole_string[whole_string.length-1]);
    // y = array.indexOf(whole_string[whole_string.length-2]);
    //  matrix[x][y] = matrix[x][y] + 1;
    //  matrix[y][x] = matrix[y][x] + 1;
  for (var i = whole_string.length-2; i >= 0; i--) {
      x = array.indexOf(whole_string[i]);
      y = array.indexOf(whole_string[i+1]);
      matrix[x][y] = matrix[x][y] + 1;
      matrix[y][x] = matrix[y][x] + 1;
      // whole_string.pop();
    }
    return matrix;
}

var matrix = create_matrix(orig_str, word_array)

console.log(matrix);

var chord = d3.layout.chord()
    .padding(0)
    .sortSubgroups(d3.descending)
    .matrix(matrix);

var width = 550,
    height = 550,
    innerRadius = Math.min(width, height) * .37,
    outerRadius = innerRadius*1.2;

function create_range(array){
  var output = [];
  for (var i = 0; i < array.length; i++) {
    output.push('#'+Math.floor(Math.random()*16777215).toString(16));
  }
  return output;
}

var range_array = create_range(word_array);

var fill = d3.scale.ordinal()
    .domain(d3.range(word_array.length))
    .range(range_array);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

svg.append("g").selectAll("path")
    .data(chord.groups)
  .enter().append("path")
    .style("fill", function(d) { return fill(d.index); })
    // .style("stroke", function(d) { return fill(d.index); })
    .attr("d", d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius))
    .on("mouseover", fade(.1))
    .on("mouseout", fade(1));

var ticks = svg.append("g").selectAll("g")
    .data(chord.groups)
  .enter().append("g").selectAll("g")
    .data(groupTicks)
  .enter().append("g")
    .attr("transform", function(d) {
      return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
          + "translate(" + outerRadius + ",0)";
    });

ticks.append("line")
    .attr("x1", 1)
    .attr("y1", 0)
    .attr("x2", 5)
    .attr("y2", 0)
    .style("stroke", "#FFF");

ticks.append("text")
    .attr("x", 8)
    .attr("dy", ".35em")
    .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
    .style("fill", "#FFF")
    .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
    .text(function(d) { return d.label; });

svg.append("g")
    .attr("class", "chord")
  .selectAll("path")
    .data(chord.chords)
  .enter().append("path")
    .attr("d", d3.svg.chord().radius(innerRadius))
    .style("fill", function(d) { return fill(d.target.index); })
    .style("opacity", 0.9);

var label_array = word_array;

// Returns an array of tick angles and labels, given a group.
function groupTicks(d) {
  var k = (d.endAngle - d.startAngle) / d.value;
  return d3.range(0, d.value, 1000).map(function(v, i) {
    // console.log("v: ", v);
    // console.log("d: ", d);
    // console.log("d.value: ", d.value);
    return {
      angle: v * k + d.startAngle,
      //label: i % 5 ? null : v / 1000 + "k"
      label: word_array[d.index]
    };
  });
}

// console.log(word_array);

// Returns an event handler for fading a given chord group.
function fade(opacity) {
  return function(g, i) {
    svg.selectAll(".chord path")
        .filter(function(d) { return d.source.index != i && d.target.index != i; })
      .transition()
        .style("opacity", opacity);
  };
}

</script>